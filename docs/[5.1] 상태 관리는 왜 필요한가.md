# 모던 리액트 Deep Dive 스터디

## 리액트와 상태 관리 라이브러리: 상태 관리는 왜 필요한가?

#### 상태란 무엇일까? 

흔히 웹 애플리케이션을 개발할 때 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다. 보통 웹 애플리케이션에서 상태로 분류될 수 있는 값은 대표적으로 다음과 같은 것이 있다.

- UI: 기본적으로 웹 애플리케이션의 상태라 함은 상호 작용(interaction)이 가능한 모든 요소의 현재 값을 의미한다. 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림창의 노출 여부 등 많은 종류의 상태가 존재한다.
- URL: 브라우저에서 관리되고 있는 상태값. `https://www.airbnb.co.kr/rooms/34113796?adults=2`와 같은 주소에서의 `roomId=34113796`과 `adults=2`라고 하는 상태가 존재하며 이 상태는 사용자의 라우팅에 따라 변경
- form: 폼에서도 상태가 존재. 로딩 중인지(loading), 제출했는지(submit), 접근이 불가능한지(disabled), 값이 유효한지(validation) 등 모두가 상태로 관리
- 서버에서 가져온 값: 클라이언트에서 서버로 요청을 통해 가져온 값도 상태로 볼 수 있다. 대표적으로 API 요청이 있다.

웹 서비스에서 점차 다양한 기능이 제공됨에 따라 웹 내부에서 관리해야 할 상태도 점차 비례해서 증가하고 있다. 애플리케이션 전체적으로 관리해야할 상태가 있다고 가정해 볼 때, 그 상태에 따라 다양한 요소들이 각 상태에 맞는 UI를 보여줘야 한다. 그렇다면 상태를 어디에 둘 것인지, 전역 변수에 둘 것인지, 별도의 클로저를 만들 것인지, 그 상태가 유효한 범위를 어떻게 제한할지, 상태의 변화에 따라 변경돼야 하는 자식 요소들은 어떻게 이 상태의 변화를 감지할 것인지 등,,,

상태를 효율적으로 관리하고, 상태가 필요한 쪽에서 빠르게 반응할 수 있는 모델에 대한 고민을 해보자

### 리액트 상태 관리의 역사 

애플리케이션 개발에 모든 것을 제공하는 `Angular`와는 다르게, 리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐이고, 그 이상의 기능은 제공하지 않고 있다. 따라서 상태를 관리하는 방법도 개발자에 따라, 시간에 따라 많은 차이가 있다. 

#### `Flux` 패턴의 등장

순수 리액트에서 할 수 있는 전역 상태 관리 수단이라고 한다면 `Context API`를 떠올리지만, 사실상 Context API는 상태 관리가 아니라 상태 주입을 도와주는 역할이다. Context API가 선보인 것은 16.3 버전이었고, useContext가 나온 것은 16.8 버전이었다. 그 전까지는, 리덕스가 나타나기 전까지 리액트 애플리케이션에서 딱히 이름을 널리 알린 상태 관리 라이브러리는 없었다.

그러던 2014년경, 리액트의 등장과 비슷한 시기에 Flux 패턴과 함께 이를 기반으로 한 라이브러리인 Flux를 소개하게 된다. 이 당시엔 웹 애플리케이션이 비대해지고 상태(데이터)도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는지 등을 추적하고 이해하기가 매우 어려운 상황이었다.

<div align="center">
  <img src="./image/mvc model.png" alt="mvc model image">
  <img src="./image/mvc pattern.webp" alt="mvc model image">
</div>

> 기존 MVC 패턴은 모델과 뷰가 많아질수록 복잡도가 증가했다.

페이스북 팀은 이러한 문제의 원인을 양방향 바인딩으로 보았다. 뷰(HTML)가 모델(자바스크립트)를 변경할 수 있으며, 반대의 경우 모델도 뷰를 변경할 수 있다. 이는 코드를 작성하는 입장에서는 간단할 수 있지만, 코드의 양이 많아지고 변경 시나리오가 복잡해질수록 관리가 어려워진다. 페이스북 팀은 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안하는데 이것이 바로 Flux 패턴의 시작이다.

> Action -> Dispatcher -> Model -> View

- 액션(action): 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미, 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
- 디스패처(dispatcher): 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
- 스토어(store): 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의되어 있다.
- 뷰(view): 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있을 것이다. 이 경우에는 아래 그림처럼 뷰에서 액션을 호출하는 구조로 구성된다.

<div align="center">
  <img src="./image/flux pattern.png" alt="mvc model image">
</div>

> Flux 패턴에서 뷰 또한 액션을 호출할 수 있으며, 이후 프로세스는 동일하다.

이 모습을 리액트 코드로 살펴보자.

```tsx
type StoreState = {
  count: number
};

type Action = { type: "add"; payload: number };

function reducer(prevState: StoreState, action: Action) {
  const { type: ActionType } = action;
  if (ActionType === "add") {
    return {
      count: prevState.count + action.payload,
    }
  }

  throw new Error(`Unexpected Action [${ActionType}]`);
}

export default function App() {
  const [state, dispatcher] = useReducer(reducer, { count: 0 });

  function handleClick() {
    dispatcher({ type: "add", payload: 1 });
  }

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={handleClick}>+</button>
    </div>
  )
}
```

여기서 스토어의 역할을 하는 것이 `useReducer`와 `reducer`이다. 각각 현재 상태와 상태에 따른 값이 어떻게 변경되는지를 정의 했다. 그리고 dispatcher로 이 액션을 실행했고, 이를 뷰인 App에서 보여준다.

물론, 단방향 데이터 흐름 방식에도 불편함이 존재한다. 사용자의 입력에 따라(사용자가 발생시키는 이벤트에 따라) 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성을 해야 하므로 코드의 양이 많아지고 개발자도 수고스러워진다. 그러나 데이터의 흐름은 모두 액션이라는 한 방향(단 방향)으로 줄어드니까 데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 한결 수월해진다.

리액트는 대표적인 단방향 데이터 바인딩을 기반으로 한 라이브러리였으므로 이러한 단방향 흐름을 정의하는 Flux 패턴과 매우 궁합이 잘 맞았다. 그리고 이와 동시에 Flux 패턴을 따르는 다양한 라이브러리들이 우후죽순처럼 등장하기 시작했다. 

- Flux
- alt
- RefluxJS
- NuclearJS
- Fluxible
- Fluxxor

상태와 그 상태의 변경에 대한 흐름과 방식을 단방향으로 채택한 것이 바로 리액트 기반 Flux의 특징이라고 볼 수 있다.

#### 리덕스의 등장

리액트와 단방향 데이터 흐름이 점점 두각을 드러내던 와중에 리덕스(Redux)가 등장한다. 리덕스 또한 최초에는 이 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나였다. 이에 한 가지 더 특별한 것은 여기에 `Elm 아키텍처`를 도입했다는 것이다. 

> Elm은 웹 페이지를 선언적으로 작성하기 위한 언어이다.

##### Elm 아키텍처의 핵심

- 모델(model): 애플리케이션의 상태를 의미한다. 
- 뷰(view): 모델을 표현하는 HTML을 말한다. 
- 업데이트(update): 모델을 수정하는 방식을 말한다.

즉, Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고, 이를 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력했다. 그리고 리덕스는 이 Elm 아키텍처의 영향을 받아 작성되었다.

리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다. 이런 작업을 reducer 함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 된다.

이러한 리덕스의 등장은 리액트 생태계에 많은 영향을 미치게 됐다. 하나의 글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props drilling 문제를 해결할 수 있었고, 스토어가 필요한 컴포넌트라면 connect만 쓰면 스토어에 바로 접근할 수 있었다.

Context API가 등장하기 전까지와 등장하고 나서도 리덕스는 리액트 상태 관리의 중요한 축으로 자리 잡았다.

그렇다고 리덕스가 마냥 장점만 있는 것은 아니었는데, 단순히 하나의 상태만 바꿔주고 싶어도 해야할 일이 너무 많았다. 어떤 액션인지 타입을 선언해야 하고, 이 액션을 수행할 creator, 함수를 만들어야 한다. 그리고 dispatcher와 selector도 필요하고, 새로운 상태가 어떻게 기존의 리듀서 내부에서 어떤 식으로 변경돼야 할지, 혹은 새로 만들어야 할지도 새로 정의해야 했다. 한마디로, 하고자 하는 일에 비해서 보일러플레이트가 너무 많다는 비판의 목소리가 있었다. (지금은 작업이 많이 간소화 되었다.)

그럼에도 불구하고, 리액트와 리덕스는 일종의 표준처럼 굳어졌다. 리덕스가 전역 상태 관리에 많은 편리함을 제공하기 시작했고, 또 뚜렷한 대안이 존재하는 것 또한 아니었다.

#### Context API와 useContext

리액트가 처음 세상에 나온 뒤에도 상태의 주입, 즉, props drilling에 대한 고민이 많았다. 물론 리덕스로 해결할 수도 있지만, 보일러 플레이트가 부담스러웠다. 이는 번거로웠고, 컴포넌트 설계에 커다란 제약으로도 작용했다.

리액트 팀은 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 Context API를 출시했다. props로 넘겨주지 않더라도 Context API를 사용하면 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 된 것이다.

하지만 Context API는 상태 관리 라이브러리가 되기 위한 조건인 아래 조건을 모두 만족하지 못하므로 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의가 필요하다.

- 어떠한 상태를 기반으로 다른 상태를 만들어 낼 수 있어야 한다.
- 필요에 따라 이러한 상태 변화를 최적화할 수 있어야 한다.

#### 훅의 탄생, 그리고 React Query와 SWR

Context API가 선보인 지 1년이 채 되지 않아 리액트는 16.8 버전에서 함수형 컴포넌트에 사용할 수 있는 다양한 훅 API를 추가했다. 이 훅 API는 기존에 무상태 컴포넌트를 선언하기 위해서만 제한적으로 사용됐던 함수형 컴포넌트가 클래스형 컴포넌트 이상의 인기를 구가할 수 있도록 많은 기능을 제공했다. 이 가운데 가장 큰 변경점 중 하나는 `useState`와 같이 state를 매우 손쉽게 재사용 가능하도록 만들 수 있다는 것이었다.

이러한 훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리가 등장하는데 바로 `React Query`와 `SWR`이다. 

두 라이브러리는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리이지만, API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다. 

```jsx
import React from 'react'
import useSWR from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

export default function App() {
  const { data, error } = useSWR(
    'https://api.github.com/repos/vercel/swr',
    fetcher,
  )

  if (error) return 'An error has occurred.'
  if (!data) return 'Loading...'

  return (
    <div>
      <p>{JSON.stringify(data)}</p>
    </div>
  )
}
```

useSWR의 첫 번째 인수인 API 주소는 키로도 사용되며, 이후에 다른 곳에서 동일한 키로 호출하면 재조회하는 것이 아니라 useSWR이 관리하고 있는 캐시의 값을 활용한다. 기존에 우리가 알고 있는 상태 관리 라이브러리보다는 제한적인 목적으로, 일반적인 형태와는 다르다는 점만 제외하면 분명히 SWR이나 React Query도 상태 관리 라이브러리의 일종이라 볼 수 있다. 실제로 두 라이브러리를 쓰면 애플리케이션의 많은 부분에서 상태를 관리하는 코드가 사라진다는 것을 알 수 있다.

#### Recoil, Zustand, Jotai, Valtio에 이르기까지

SWR과 React Query가 HTTP 요청에 대해서만 쓸 수 있다면 좀 더 범용적으로 쓸 수 있는 상태 관리 라이브러리엔 어떤 변화가 있었을까?

훅이라는 새로운 패러다임의 등장에 따라, 훅을 활용해 상태를 가져오거나 관리할 수 있는 다양한 라이브러리가 등장하게 된다. 페이스북 팀에서 만든 Recoil(개발 중지)을 필두로, Jotai, Zustand, Valtio 등 다양한 라이브러리가 선보이게 된다.

요즘 새롭게 떠오르고 있는 많은 상태 관리 라이브러리는 기존의 리덕스 같은 라이브러리와는 차이점이 있는데, 바로 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다는 것이다. (리덕스는 액션과 리듀서를 통해 좀 더 구조화하고 중앙 집중적인 상태 관리를 함). Recoil, Jotai, Zustand, Valtio의 저장소를 방문해 보면 모두 `peerDependencies`로 리액트 16.8 버전 이상을 요구하고 있음을 확인할 수 있다. 물론 리덕스나 MobX도 `react-redux`나 `mobx-react-lite` 등을 설치하면 동일하게 훅으로 상태를 가져올 수 있지만, 위 라이브러리는 애초에 리액트와의 연동을 전제로 작동해 별도로 다른 라이브러리를 설치하지 않아도 된다는 차이점이 있다.

### 정리

너무 많은 선택지로 인해 실제로 애플리케이션을 작성할 때 무엇을 선택해야 할지 고민스러울 수 있지만 하나의 이슈에 대해 여러가지 해결책이 나온다는 것은 그만큼 이 분야가 건강하게 성장하고 있다는 증거이기도 하다.
