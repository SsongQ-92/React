# 모던 리액트 Deep Dive 스터디

## 들어가며

### 리액트의 사용 이유

1. 명시적인 상태 변경
   리액트는 단방향 바인딩만 지원하는데, 리액트의 상태 변화는 `단방향`으로, 그리고 `명시적`으로 이루어진다.
   - 장점: 단방향 바인딩의 경우, 상태가 변화했다면 그 상태 변화를 명시적으로 일으킨 함수만 찾으면 된다. 데이터 흐름의 변화가 단순하여 코드를 읽기 쉽고, 버그를 야기할 가능성이 비교적 적다.
   - 단점: 단방향 바인딩은 항상 변화를 감지하고 업데이트하는 코드를 매번 작성해야해서, 코드의 규모가 증가하는 단점이 있다.
     > Angular의 경우 양방향 바인딩인데, 양방향으로 바인딩되면 뷰의 변화가 컴포넌트에 영향을 미칠 수도, 반대로 컴포넌트의 상태가 변경되면 뷰의 상태도 변할 수 있다. 양방향 바인딩의 경우 규모가 커질수록 상태의 변화가 무엇으로 인해 일어났는지 파악하기 어려워지는 단점이 있다. 변경된 DOM을 추적하는 것이 어렵고, 이로 인해 버그가 야기될수도

```js
// 리액트의 경우 name이 변경된 이유를 알고 싶다면 setName을 호출하는 곳만 찾으면 됨
function App {
  const [name, setName] = useState('');

  function onChange(e) {
    setName(e.target.value);
  }

  return <input type="text" value={name}>
}
```

2. JSX

- 기존에 알고 있는 자바스크립트 문법에 HTML을 약간 가미한 수준
  > Angular는 뷰를 표현하기 위해 문자열 템플릿을 사용하고 ngIf처럼 Angular에서만 사용되는 전용 문법을 익혀야함

3. 배우기 쉽고 간결함

- 처음 접하기는 쉽다. 즉, 러닝 커브가 낮고 완만. 하지만, 완벽히 이해하고 성능을 최적화하는 것은 상대적으로 어려운 축에 속함

4. 강력한 커뮤니티

### 웹 개발의 간략한 역사

1. [2000년대] `LAMP 스택` => 리눅스(Linux), 아파치(Apache) 웹 서버, MySQL, PHP
2. [2010년대] `jQuery` => 제이쿼리와 제이쿼리 플러그인의 인기, 자바스크립트의 비공식 표준으로 자리잡기 시작
3. 인터넷 익스플로러 8에 등장한 `로컬 스토리지`
4. 2011년 공식적으로 표준으로 등록된 `웹소켓(WebSocket)`
5. 자바스크립트로 그래픽을 표현할 수 있도록 도와준 `캔버스(Canvas)`나 벡터 그래픽을 표현할 수 있는 `SVG`, 사용자의 위치를 알 수 있는 `지오로케이션(Geolocation)`의 등장
6. `ES5(ECMAScript 5)`가 처음으로 표준 스펙으로 자리 잡음
7. 자바스크립트의 `DOM(Document Object Model)` 적극적 수정
8. `Ajax(Asynchronous JavaScript and XML)`를 활용해 클라이언트에서도 서버와 통신하여 데이터를 불러옴
9. `MVVM(Model-View-ViewModel)`과 `MVC(Model-View-Controller)` 패턴의 `AngularJS`와 `Backbone.js`의 등장
10. 페이스북 이용자 증가 => 모든 것을 서버사이드 렌더링으로 하기에는 무리(페이지 전체가 로딩되어 전체 화면이 깜빡이거나 느리게 작동하는 것처럼 보임) => 실시간성을 강조하기 위한 기능들 추가 => 그럼에도 증가되는 자바스크립트에 대한 의존
11. 스파르탄 프로젝트(`HTML5` 기반으로 애플리케이션 재작성하여 하이브리드 앱으로 개발)
12. 스파르탄 프로젝트 실패, iOS용 페이스북 앱을 네이티브로 개발, 안드로이드 네이티브 페이스북 앱 출시 => 스파르탄 프로젝트의 실패가 긍정적 영향을 줌, 앱과 모바일, PC에서 동이랗ㄴ 사용자 경험을 주고자 했던 도전!
13. `BoltJS`의 등장 및 한계 직면, `FBold(Functional Bolt)` 등장(`React`의 시초) => 이 당시 제안되었던 아이디어 중 하나가 앱에서 API의 변화에 따라 무언가 변경되면 단순히 UI를 초기화하고 새로 렌더링하자는 파격적 아이디어, 당시의 대부분의 프레임워크는 양방향 바인딩 구조였기 때문
14. 리액트의 첫 프로젝트 => 댓글, 공유 버튼에 대한 `UFI(Universal Feedback Interface)` 구현 => 여기서 `JSX 구문`과 `Flux 패턴`에 대한 아이디어 등장
15. 페이스북의 인스타그램 인수, 인스타그램은 당시 iOS와 안드로이드 버전 밖에 없었고, 웹을 만드는 작업에 착수 => `BoltJS`, 바닐라 자바스크립트와 HTML, `React` 세 가지 선택지 => 리액트 선택하여 개발 착수
16. `JSConf US`에서 리액트와 함께 `embedded XML`인 `JSX`도 함께 공개

### Flux 패턴

2014년 페이스북에서 도입한 새로운 아키텍처
Flux 패턴은 사용자 입력을 기반으로 Action을 생성하고, 이를 Dispatcher에 전달하여 Store의 데이터를 변경한 뒤 View에 반영하는 단방향의 데이터 흐름을 가지는 소프트웨어 아키텍처이다. `MVC(Model-View-Controller)`패턴과는 다르게 Flux 패턴으로 구현된 프로젝트는 데이터가 단방향으로만 전달되기 때문에 데이터의 흐름을 파악하기가 용이하고, 그 결과를 쉽게 예측할 수 있다는 장점을 가진다.

<img src="./image/flux.jpg" alt="flux 패턴">

이러한 Flux 패턴에 Dan Abramov라는 개발자가 Reducer를 결합하여 만든 것이 바로 리덕스(Redux)이다.

> [출처](https://www.tcpschool.com/react/react_redux_intro#:~:text=Flux%20%ED%8C%A8%ED%84%B4%EC%9D%80%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%9E%85%EB%A0%A5,%EC%9D%84%20%EA%B0%80%EC%A7%80%EB%8A%94%20%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9E%85%EB%8B%88%EB%8B%A4.)

### 리액트의 다양한 라이브러리

- 상태 관리: Redux, Zustand, Recoil(지원 중단), Jotai
- 서버 사이드 렌더링(SSR): Next.js, Remix, Hydrogen
- 애니메이션: Framer Motion, react-spring, React Move
- 차트: Recharts, visx, nivo
- 폼: React Hook Form, Formik, React Final Form

### 현재 리액트 개발자들 집중적으로 개발하고 있는 것

현재 가장 집중적으로 개발자들이 역량을 쏟고 있는 것은 서버에서의 리액트 활용이다. 서버에서 어떻게 리액트를 효율적으로 사용할 수 있을지에 대해 고민 중이라고 한다. 서버에서 작동할 수 있는 다양한 기능이나 클라이언트에서 할 수 없는 서버에서의 작업을 위주로 개발할 것으로 보인다. 이에 따라 앞으로 리액트를 계속 사용하고 공부할 프론트엔드 개발자들은 Node.js 같은 서버 환경을 공부하는 것이 기본 소양으로 자리 잡을 것 같다.
