# 모던 리액트 Deep Dive 스터디

## 리액트 훅으로 시작하는 상태 관리

### 가장 기본적인 방법: useState와 useReducer

```tsx
// 함수형 컴포넌트 어디에서든 사용할 수 있게 구현한 사례

function useCounter(initCount: number = 0) {
  const [counter, setCounter] = useState(initCount);

  function inc() {
    setCounter((prev) => prev + 1);
  }

  return { counter, inc };
}
```

해당 훅이 없었다면 각각의 컴포넌트에서 모두 위와 같은 내용을 구현해야만 했을 것이다. 더 나아가 훅 내부에서 관리해야 하는 상태가 복잡하거나 상태를 변경할 수 있는 시나리오가 다양해진다면 훅으로 코드를 격리해 제공할 수 있다는 장점이 더욱 크게 드러날 것이다. 이처럼 사용자 정의 훅은 함수형 컴포넌트라면 어디서든 손쉽게 재사용 가능하다는 장점이 있다.

useReducer 또한 useState와 마찬가지로 지역 상태를 관리할 수 있는 훅이다.

```tsx
// useReducer로 useState를 구현, 실제로 useState는 useReducer로 구현되었다.

type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

function useStateWithUseReducer<T>(initialState: T) {
  const [state, dispatch] = useReducer(
    (prev: T, action: Initializer<T>) => 
      typeof action === 'function' ? action(prev) : action,
    initialState,
  )

  return [state, dispatch];
}
```

```jsx
// useState로 useReducer 구현

function useReducerWithUseState(reducer, initialState, initializer) {
  const [state, setState] = useState(
    initializer ? () => initializer(initialState) : initialState,
  )

  const dispatch = useCallback(
    (action) => setState((prev) => reducer(prev, action)),
    [reducer],
  )

  return [state, dispatch];
}
```

useState와 useReducer 모두 지역 상태 고나리를 위해 만들어졌다. 하지만 이 둘 모두 상태 관리의 모든 필요성과 문제를 해결해 주지는 않는다. useState와 useReducer를 기반으로 하는 사용자 지정 훅의 한계는 명확하다. 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다. (컴포넌트별 상태의 파편화)

만약 두 개 이상의 컴포넌트가 동일한 상태를 바라보게 하기 위해서는 어떻게 해야 할까? 즉, 지역 상태를 여러 컴포넌트가 동시에 사용할 수 있는 전역 상태(global state)로 만들어 컴포넌트가 사용하는 모든 훅이 동일한 값을 참조할 수 있게 하려면 어떻게 해야 할까? 가장 쉬운 방법은 컴포넌트 밖(공통 부모)으로 끌어 올리는 것이다.

컴포넌트 내부의 지역 상태를 전역으로 사용하기 위해 이 상태가 필요한 모든 컴포넌트를 부모 컴포넌트 내부로 이동시켜 상태를 주입한다. props 형태로 필요한 컴포넌트에 제공해야 한다는 점은 여전히 불편해 보인다.

### 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

현재 리액트의 useState는 리액트가 만든 클로저 내부에서 관리되어 지역 상태로 생성되기 때문에 해당 컴포넌트에서만 사용할 수 있다는 단점이 있다. 만약 useState가 이 리액트 클로저가 아닌 다른 자바스크립트 실행 문맥 어디에선가, 즉 완전히 다른 곳에서 초기화돼서 관리되면 어떨까? 그리고 그 상태를 참조하는 유효한 스코프 내부에서는 해당 객체의 값을 공유해서 사용할 수도 있지 않을까? 즉, 어딘가에서 해당 값을 업데이트하면 그 값을 참조하고 있는 컴포넌트나 훅에서도 그 업데이트된 값을 사용할 수도 있지 않을까?

```ts
// counter.ts
export type State = { counter: number };

// 상태를 아예 컴포넌트 밖에 선언. 각 컴포넌트가 이 상태를 바라보게 한다.
let state: State = {
  counter: 0,
}

// getter
export function get(): State {
  return state;
}

// useState와 동일하게 구현하기 위해 게으른 초기화 함수나 값을 받을 수 있게 한다.
type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

// setter
export function set<T>(nextState: Initializer<T>) {
  state = typeof nextState === 'function' ? nextState(state) : nextState
}

// Counter
function Counter() {
  const state = get();

  function handleClick() {
    set((prev: state) => ({ counter: prev.counter + 1 }));
  }

  return ...
}

```

하지만 이러한 방식은 잘 작동할 것 같지만 리액트 환경에서 작동하지 않는다. state를 return 해주고 update하는 getter와 setter 등의 코드가 잘못된 것이 아니다. 브라우저에서 살펴보면 컴포넌트 외부에 있는 state가 잘 업데이트되고 있고, 최신값도 getter로 잘 가져온다. 하지만 문제는 컴포넌트가 리렌더링 되지 않는 것이다. 원인은 바로 리액트의 렌더링 방식 때문이다. 새로운 상태를 사용자의 UI에 보여주기 위해서는 반드시 리렌더링이 필요하다. 이 리렌더링은 함수형 컴포넌트의 재실행(호출), useState의 두 번째 인수 호출 등 다양한 방식으로 일어나지만 위의 방식으로는 리렌더링을 일으키는 장치가 어디에도 존재하지 않는다.

즉, 업데이트되는 값을 가져오려면 상태를 업데이트하는 것 뿐 아니라 상태가 업데이트됐을 때 이를 컴포넌트에 반영시키기 위한 리렌더링이 필요하며, 리렌더링을 하려면 아래 작업 중 하나가 일어나야 한다.

- useState, useReducer의 반환값 중 두 번째 인수가 어떻게든 호출된다. 설령 그것이 컴포넌트 렌더링과 관계없는 직접적인 상태를 관리하지 않아도 상관없다. 어떠한 방식으로든 두 번째 인수가 호출되면 리액트는 다시 컴포넌트를 렌더링한다.
- 부모 함수(부모 컴포넌트)가 리렌더링되거나 해당 함수(함수형 컴포넌트)가 다시 실행돼야 한다. 그러나 위 경우 부모 컴포넌트가 없으며, props도 없기 때문에 일일이 Counter()를 재실행시켜야 하지만 그것은 매우 비효율적.

여기서 시도해 볼 수 있는 것은 useState와 useReducer 뿐이다. 그렇다면 useState의 인수로 컴포넌트 밖에서 선언한 state를 넘겨주는 방식으로 코드를 변경해 보자.

```jsx
function Counter1() {
  const [count, setCount] = useState(state);

  function handleClick() {
    // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음,
    // 그 값을 로컬 상태값에도 넣는다.

    set((prev: State) => {
      const newState = { counter: prev.counter + 1}
      setCount(newState)
      return newState
    })
  }

  return (
    ...
  )
}
```

이 방법은 굉장히 비효율적이고 문제점도 가지고 있다. 외부에 상태가 있음에도 불구하고, 함수형 컴포넌트의 렌더링을 위해 함수의 내부에 동일한 상태를 관리하는 useState가 존재하는 구조다. 이는 상태를 중복해서 관리하므로 비효율적인 방식이다. 또 한 가지 문제점은, 실제로 각 컴포넌트 내부의 이벤트가 이상하게 동작하는 것을 확인할 수 있다. 만약 버튼을 누르면 해당 컴포넌트가 렌더링되면서 원하는 값을 안정적으로 렌더링하지만 같은 상태를 바라봐야 하는 반대쪽 컴포넌트에서는 렌더링되지 않는다. 반대쪽 컴포넌트는 버튼을 눌러야 그제서야 렌더링되어 최신값을 불러온다. 왜 같은 상태를 공유하지만 동시에 렌더링되지 않는 것일까?




